# Alloy model for [gitbom](https://gitbom.dev)

I've been trying to use [Alloy](https://alloytools.org) to [specify
gitbom](gitbom.als). This is mostly for my own understanding, but it's also
useful for shaking out any imprecision.

I'm basing this off the glossary pages:
- [artifact](https://gitbom.dev/glossary/artifact/)
- [artifact tree](https://gitbom.dev/glossary/artifact_tree/)
- [GitBOM](https://gitbom.dev/glossary/gitbom/)

and it's intended to reflect the current design.

## Simplified spec - implicit OIDs

The [simplified spec](gitbom-no-oid.als) has objects directly reference each other.
In this model, OIDs are implicit.

The meta-model is as follows:
- Two types of [`Artifact`](https://gitbom.dev/glossary/artifact/):
  - [`LeafArtifact`](https://gitbom.dev/glossary/artifact/#leaf-artifacts) which is typically human-written.
  - [`DerivedArtifact`](https://gitbom.dev/glossary/artifact/#derived-artifacts) which is generated by some build step.
- [`BomDoc`](https://gitbom.dev/glossary/gitbom/#gitbom-document) (aka "GitBOM Document"), which is a set of references to inputs. `LeafArtifacts` can be referenced directly.
  - `DerivedRef` mediates references to `DerivedArtifacts`, because they're also tied to the `BomDoc` for the build step which generated it.

![No-OID meta-model](images/model-no-oid.png)

An example instance of this model:

![Example instance](images/instance-no-oid.png)

## Spec with OIDs

The [more detailed spec](gitbom-oid.als) explicitly includes OIDs. This is
closer to the real system, but the OIDs add a lot of extra complexity.  However,
once we start to consider how to handle constructing OIDs with multiple hash
functions, we'll need the explicit representation.

![OID meta-model](images/model-oid.png)

With an example instance:

![Example OID instance](images/instance-oid.png)

# Observations

This is just a snapshot of my understanding of the writeup on gitbom.dev &mdash;
I could easily have got things wrong. Some misc things I noticed.

## GitBOM documents only encode inputs

GitBOM documents (BomDocs) only encode input artifacts. But they do not encode
what build action was actually taken, nor what outputs were generated. So two
different build actions producing different derived output artifacts would
reference the same BomDoc.

Related to this, there's no real way of distinguishing how many actions were
run, or what outputs they had, except by looking for all the derived
artifact+bom references (`DerivedRef` here) which exist in the graph.

I think this means that the BomDoc needs to either encode - as part of its
identity - either what the build action was, or what the output artifacts were.
Since the output artifacts are more important as far as determining provenance
is concerned, they're probably preferable. (Unless you can guarantee
deterministic output from tools, the build action on its own is not enough
anyway.)
## Derived artifacts

One not immediately obvious constraint was that a BomDoc cannot depend on a
given derived artifact and another BomDoc which also depends on that derived
artifact (this is a stronger constraint than acyclic BomDoc graph). For example:

![diamond derivation](images/diamond-derived.png)

Also here's an example of a BomDoc depending on a derived artifact twice,
generated by two different build actions. Presumably this is a case where two
actions ended up producing identical outputs, and a third action ends up depending on both.

![Duplicate outputs](images/converged-outputs.png)

One way this could arise is if `DerivedArtifact0` were actually something simple
like an empty file - it's easy to imagine two separate actions both emitting
that. But of course there are also possibilities where it could be a non-trivial
file.
## Misc
- I assume a GitBOM document must have at least one input (and one output if we're also recording those).
